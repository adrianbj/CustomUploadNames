<?php

/**
 * ProcessWire Rename Uploads
 * by Adrian Jones
 *
 * Automatically rename file (and image) uploads according to a configurable format
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessCustomUploadNames extends Process implements Module, ConfigurableModule {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => __('Custom Upload Names'),
            'version' => 16,
            'summary' => __('Automatically rename file (including image) uploads according to a configurable format'),
            'singular' => true,
            'autoload' => true,
            );
    }


   /**
     * Default configuration for module
     *
     */
    static public function getDefaultData() {
            return array(
                "enabledFields" => "",
                "enabledPages" => "",
                "enabledTemplates" => "",
                "filenameFormat" => "",
                "fileExtensions" => "",
                "filenameLength" => ""
            );
    }

    /**
     * Populate the default config data
     *
     */
    public function __construct() {
       foreach(self::getDefaultData() as $key => $value) {
               $this->$key = $value;
       }
    }


    public function ready() {
        // we're interested in page editor only
        //if(wire('page')->process != 'ProcessPageEdit') return;

        // skip changing templates (only target the actual edit form)
        //$id = (int)$this->input->get->id;
        //if(!$id) return;

        // wire('page') would be the page with ProcessPageEdit
        // GET parameter id tells the page that's being edited
        //$this->editedPage = wire('page');

        $this->addHookBefore('Pagefile::install', $this, 'customRenameUploads');
        $this->addHookBefore('InputfieldFile::processInputAddFile', $this, 'customRenameUploads');
    }


    public function customRenameUploads(HookEvent $event) {
        //error_log('CALLED');
        $filename = $event->arguments(0);
        //error_log('Initial Filename:'.$filename);

        if(!isset($event->object->field->id) || $event->object->field->id == ''){
            $upload = 'admin';
            $pageid = $this->input->get->id;
            $field = $event->object;
            $fieldid = $this->fields->get($field->name)->id;
        }
        else{
            $upload = 'api';
            $pageid = $event->object->page->id;
            $fieldid = $event->object->field->id;
        }

        $editedPage = wire('pages')->get($pageid);

        //error_log('UPLOAD:'.$upload);
        //error_log('PID:'.$pageid.' : FID:' . $fieldid);


        // ruleData is a json string that we need to turn into an object
        $rules = json_decode($this->ruleData);

        // Iterate through each of the rename rules
        foreach ($rules as $rule) {

            foreach(explode("|",$editedPage->parents) as $parent){
                $parentEnabled = in_array($parent, $rule->enabledPages) || in_array(1, $rule->enabledPages) ? true : false;
            }

            if((count($rule->enabledTemplates) != 0 && !in_array($editedPage->template->id, $rule->enabledTemplates))) continue;

            if($rule->enabledPages[0] != '' && !in_array($editedPage->id, $rule->enabledPages) && !$parentEnabled) continue;

            if(count($rule->enabledFields) != 0 && !in_array($fieldid, $rule->enabledFields)) continue; //if fields set and this is not a selected field

            if($rule->fileExtensions != '' && !in_array(pathinfo($filename, PATHINFO_EXTENSION), explode(",", trim(str_replace(', ',',',$rule->fileExtensions))))) continue; //if fileExtensions is set and the uploaded file does not match

            //the basename check determines whether the path needs adding to the filename or not. The original image doesn't have the path, but the thumbnail does.
            //So if it is the thumbnail, we just return as we don't need to rename it again
            //error_log('FILENAME:'.$filename.':BASENAME:'.basename($filename));
            if(basename($filename) == $filename) {
                $filename = $this->pages->get("$pageid")->filesManager()->path() . basename($filename);
            }
            elseif($upload == 'api'){
                //if api upload then need to keep the filename / path as is since we'll be renaming it in its source location. Not ideal, but if Pagefile::install hook is set to 'after' then you can't set the $event argument to change the filename.
                //also none of the InputfieldFile hooks get called when uploading via the API, so I think this might be the only choice, although making Pagefile::setFilename hookable might help.
            }
            else{
                continue;
            }

            if(strpos($filename, '://')) continue; // don't attempt to rename http-based files

            if($rule->filenameFormat == '') continue; // don't attempt to rename if the filename format field is empty

            $newFilename = $this->createNewFilename($filename, $rule->filenameFormat, $rule->filenameLength, $pageid);
            //error_log($filename.':'.$newFilename);

            if(file_exists($filename)) rename($filename, $newFilename);
            $event->setArgument(0, $newFilename); // update the argument to the install function
        }

    }

    /**
     * Generate the new filename based on the user set config options
     *
     */
    public function createNewFilename($filename, $newname, $filenameLength, $pageid){
        $n = 0;
        $path_parts = pathinfo($filename);
        $page = $this->pages->get($pageid);

        // Grab filename format and eval it. I am thinking about ditching the evil eval approach and going with a template style system like I did in the Phone Fieldtype module
        // The two commented out options allow for full flexibility (the user can use php functions etc, but makes formatting more complicated)
        //$newname = $this->sanitizer->pageName(eval($newname), true);
        //$newname = $this->sanitizer->pageName(eval("return $newname;"), true);
        $newname = $this->sanitizer->pageName(eval('return "'.$newname.'";'), true);

        if($filenameLength != '') $newname = $this->truncate($newname, $filenameLength);

        if($newname == '') $newname = 'missing-filename-format-in-custom-upload-names-module-config';

        do {
            $finalFilename = $path_parts['dirname'] . '/' . $newname . ($n === 0 ? '' : '-' . $n) .  '.' . $path_parts['extension'];
            $n++;
        } while(file_exists($finalFilename));

        return $finalFilename;

    }



    static public function getModuleConfigInputfields(array $data) {

            // this is a container for fields, basically like a fieldset
            $fields = new InputfieldWrapper();

            // Populate $data with the default config, because if they've never configured this module before,
            // the $data provided to this function will be empty. Or, if you add new config items in a new version,
            // $data won't have it until they configure it. Best bet is to merge defaults with custom, where
            // custom overwrites the defaults (array_merge).

            $data = array_merge(self::getDefaultData(), $data);

            // Populate the $fieldsModel with data for each field
            $fieldsModel = array(
                    'enabledFields' => array(
                                    'label' => "Enabled Fields",
                                    'desc' => "If no fields are chosen, renaming will be applied to all file and image fields.",
                                    'type' => "_createInputfieldAsmSelect",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'fieldsetname'=>'Rename Rules',
                                    'fieldsetdescription'=>'Add as many different rules as you need. They are processed in order, so put more specific rules before more general ones. You can drag to change the order of rules as needed.',
                                    'width' => 15),
                    'enabledTemplates' => array(
                                    'label'=>"Enabled Templates",
                                    'desc'=>"If no templates are chosen, renaming will be applied to all templates.",
                                    'type'=>"_createInputfieldAsmSelect",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'width'=>16),
                    'enabledPages' => array(
                                    'label'=>"Enabled Pages",
                                    'desc'=>"AND THEIR CHILDREN. If no pages are chosen, renaming will be applied to all pages.",
                                    'type'=>"_createInputfieldPageListSelectMultiple",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'width'=>17),
                    'fileExtensions' => array(
                                    'label'=>"File Extensions",
                                    'desc'=>"Comma separated list of file extensions that you want to apply this rule to. If none are entered renaming will be applied to all extensions.",
                                    'type'=>"_createInputfieldText",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'width'=>17),
                    'filenameFormat' => array(
                                    'label'=>"Filename Format",
                                    'desc'=>'Format for the filename. You can use plain text and the $page variable, eg. mysite-{$page->path}. You can also leave this blank so that no renaming will occur with this rule.',
                                    'type'=>"_createInputfieldText",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'width'=>25),
                    'filenameLength' => array(
                                    'label'=>"Filename Length",
                                    'desc'=>'Truncate filename to x characters (nearest whole word).',
                                    'type'=>"_createInputfieldText",
                                    'options' => "",
                                    'notes' => "",
                                    'fieldset'=>'renameRules',
                                    'width'=>10),
                    'ruleData' => array(
                                    'label'=>"Rule Data",
                                    'desc'=>"JSON string of the rule data",
                                    'type'=>"_createInputfieldHidden",
                                    'options' => "",
                                    'notes' => "")
            );
            // Now use $data and $fieldsModel loop to create all fields
            $fieldset = '';

            foreach ($fieldsModel as $f=>$fM){
                    $fM['width'] = isset($fM['width']) ? $fM['width'] : 100;
                    if (isset($fM['fieldset'])) {
                            if ($fM['fieldset'] != $fieldset) {
                                    $fieldset = $fM['fieldset'];
                                    ${$fM['fieldset']} = wire('modules')->get("InputfieldFieldset");
                                    ${$fM['fieldset']}->label = $fM['fieldsetname'];
                                    ${$fM['fieldset']}->description = $fM['fieldsetdescription'];
                                    ${$fM['fieldset']}->id = str_replace(' ', '', $fM['fieldsetname']);
                                    ${$fM['fieldset']}->set('collapsed', Inputfield::collapsedNo);
                            }
                            // For Jquery to work we want all rename rules fields in a wrapper of their own, so skip adding the field here
                            if ($fM['fieldset'] != 'renameRules') {
                                    ${$fM['fieldset']}->add(
                                            self::$fM['type']($f, $fM['label'], $data[$f], $fM['desc'], $fM['options'], $fM['notes'], $fM['width'])
                                    );
                            }
                            $fields->add(${$fM['fieldset']});
                    } else {
                            $fields->add(
                                    self::$fM['type']($f, $fM['label'], $data[$f], $fM['desc'], $fM['options'], $fM['notes'], $fM['width'])
                            );
                    }
            }

            $data['renameRules'] = !empty($data['ruleData']) ? json_decode($data['ruleData'], true) : array(0 => array('enabledFields' => '', 'enabledTemplates' => '', 'enabledPages' => '', 'fileExtensions' => '', 'filenameFormat' => ''));
            // If we have more rules stored then load extra rows
            if (!empty($data['renameRules'])) {
                    foreach ($data['renameRules'] as $k => $rule) {
                            $rulewrapper = new InputfieldWrapper();
                            $rulewrapper->add(self::_createInputfieldAsmSelect('enabledFields', 'Enabled Fields', $rule['enabledFields'], $fieldsModel['enabledFields']['desc'], '', '', 15, $k));
                            $rulewrapper->add(self::_createInputfieldAsmSelect('enabledTemplates', 'Enabled Templates', $rule['enabledTemplates'], $fieldsModel['enabledTemplates']['desc'], '', '', 16, $k));
                            $rulewrapper->add(self::_createInputfieldPageListSelectMultiple('enabledPages', 'Enabled Pages', $rule['enabledPages'], $fieldsModel['enabledPages']['desc'], '', '', 17, $k));
                            $rulewrapper->add(self::_createInputfieldText('fileExtensions', 'File Extensions', $rule['fileExtensions'], $fieldsModel['fileExtensions']['desc'], '', '', 17));
                            $rulewrapper->add(self::_createInputfieldText('filenameFormat', 'Filename Format', $rule['filenameFormat'], $fieldsModel['filenameFormat']['desc'], '', '', 25));
                            $rulewrapper->add(self::_createInputfieldText('filenameLength', 'Filename Length', $rule['filenameLength'], $fieldsModel['filenameLength']['desc'], '', '', 10));

                            $renameRules->add($rulewrapper);
                    }
            } else {

            }
            return $fields;
    }

    /**
     * Initialize the module
     */
    public function init() {

        // Check for AJAX request and process as appropriate
        if($this->config->ajax) {
                if ($this->input->get->addRule) {
                        $this->addRule($this->input->get->addRule);
                }
        }

        // Load jQuery Core if not a post request
        if(!$this->isPost) $this->modules->get('JqueryCore');

        // Initialize the module
        parent::init();
    }

    public function addRule($id) {
            $fields = new InputfieldWrapper();
            $fields->add($this->_createInputfieldAsmSelect('enabledFields', 'Enabled Fields', '', 'If no fields are chosen, renaming will be applied to all file and image fields.', '', '', 15, $id));
            $fields->add($this->_createInputfieldAsmSelect('enabledTemplates', 'Enabled Templates', '', 'If no templates are chosen, renaming will be applied to all templates.', '', '', 16, $id));
            $fields->add($this->_createInputfieldPageListSelectMultiple('enabledPages', 'Enabled Pages', '', 'AND THEIR CHILDREN If no pages are chosen, renaming will be applied to all pages.', '', '', 17, $id));
            $fields->add($this->_createInputfieldText('fileExtensions', 'File Extensions', '', 'Comma separated list of file extensions that you want to apply this rule to. If none are entered renaming will be applies to all extensions.', '', '', 17));
            $fields->add($this->_createInputfieldText('filenameFormat', 'Filename Format', '', 'Format for the filename. You can use plain text and the $page variable, eg. mysite-{$page->path}. You can also leave this blank so that no renaming will occur with this rule.', '', '', 25));
            $fields->add($this->_createInputfieldText('filenameLength', 'Filename Length', '', 'Truncate filename to x characters (nearest whole word).', '', '', 10));
            echo $fields->render();
            exit;
    }

    private static function _createInputfieldText($ipName, $ipTitle, $ipValue='', $ipDesc='', $ipOptions='', $ipNotes='', $ipWidth, $ipRequired=false){
            $field =  wire('modules')->get("InputfieldText");
            $field->name = $ipName;
            $field->label = $ipTitle;
            $field->required = $ipRequired;
            $field->description = $ipDesc;
            $field->attr('value', $ipValue);
            $field->attr('notes', $ipNotes);
            $field->columnWidth = $ipWidth;
            return $field;
    }

    private static function _createInputfieldAsmSelect($aName, $aTitle, $aValue, $aDesc='', $aOptions='', $aNotes='', $aWidth=100, $aID=1) {
            $field = wire('modules')->get("InputfieldAsmSelect");
            $field->name = $aName;
            $field->label = $aTitle;
            $field->description = $aDesc;
            if($aName == 'enabledFields'){
                foreach(wire('fields') as $currfield) {
                    if($currfield->flags & Field::flagSystem) continue;
                    if($currfield->type instanceof FieldtypeImage || $currfield->type instanceof FieldtypeFile) $field->addOption($currfield->id, $currfield->name);
                }
            }
            if($aName == 'enabledTemplates'){
                foreach(wire('templates') as $currtemplate) {
                    if($currtemplate->flags & Template::flagSystem) continue;
                    $field->addOption($currtemplate->id, $currtemplate->name);
                }
            }
            $field->attr('value', $aValue);
            $field->columnWidth = $aWidth;
            $field->setAsmSelectOption('sortable', false);
            return $field;
    }


    private static function _createInputfieldPageListSelectMultiple($ipName, $ipTitle, $ipValue='', $ipDesc='', $ipOptions='', $ipNotes='', $ipWidth=100, $ipID=1){
            $field =  wire('modules')->get("InputfieldPageListSelectMultiple");
            $field->name = $ipName;
            $field->label = $ipTitle;
            $field->description = $ipDesc;
            $field->attr('value', $ipValue);
            $field->attr('id', $ipName . $ipID); // Allows us to add more of these with different IDs via AJAX
            $field->set('unselectLabel', 'Unselect');
            $field->columnWidth = $ipWidth;
            //$field->sortable = false; // this doesn't work - is there an alternative of setAsmSelectOption('sortable', false); that works for PageListSelectMultiple fields ?
            if($ipValue == 0) $field->collapsed = Inputfield::collapsedNo;
            return $field;
    }

    private static function _createInputfieldHidden($tName, $tTitle, $tValue, $tDesc='', $ipOptions=''){
            $field = wire('modules')->get("InputfieldHidden");
            $field->name = $tName;
            $field->label = $tTitle;
            $field->description = $tDesc;
            $field->attr('value', $tValue);
            return $field;
    }

    public function truncate($text, $length){
        if(strlen($text) > $length){
            return substr( $text, 0, strrpos( substr( $text, 0, $length), '-' ) );
        }
        else{
            return $text;
        }
    }

    public function ___install() {
            $data = array();
            $module = 'ProcessCustomUploadNames';
            wire('modules')->saveModuleConfigData($module, $data);
    }

}
